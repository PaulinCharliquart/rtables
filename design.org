* Layout + rtabulate
** Option 1
#+BEGIN_CODE  
l = add_rowby_all_multi("AGE", "SEX")
rtabulate(df, layout = l, t_summary)
#+END_CODE
*** Pros
- More similar to what is done now
*** Cons
- How do we specify different fuctions for different rows?
  Things will usually be the default, but if we ever need different behavior adding
  arguments to t_summary isn't the right way to support them in general

** Option 2
#+BEGIN_CODE 
l = add_rowby_all("AGE", FUN = t_summary) %>% add_rowby_all("SEX", FUN = length)
rtabulate(df, layout = l)
#+END_CODE
*** Pros
- Easy to define different behavior for different rows as desired
- Completely trivial to create same table from different dataset once layout  object is created
*** Cons
- No easy way to say you want to create a table with same structure but different functions
- Can export premade layouts for well-defined table types


* Layout and rtabulate v2

Each subtable has *2* relevant quantities: a set of variable(s)
containing the data to be tabulated, and a definition of any splitting
used

Examples

| splitting | data            | behavior                                         | invocation                                             | resulting table structure |
|-----------+-----------------+--------------------------------------------------+--------------------------------------------------------+---------------------------|
| all       | AGE             | summarize  AGE variable                          | add_rowby_all(layout, "AGE")                           | flat multi rows           |
| SEX       | AGE             | summarize  AGE separately for  each value of SEX | add_rowby(layout, "AGE", by = "SEX")                   | nested, branch on SEX     |
| all       | SEX             | summarize  SEX variable                          | add_rowby_all(layout, "SEX")                           | flat multi rows           |
| AE, SOC   | PD              | summarize PD for each 2-level split of AE x SOC  | add_rowby_hierarchy(layout, "PD", by = c("AE", "SOC")) | nested branch on AE(SOC)  |
| AE, SOC   | fun(var1, var2) | summarize PD for each 2-level split of AE x SOC  | add_rowby_hierarchy(layout, "PD", by = c("AE", "SOC")) | nested branch on AE(SOC)  |
|           |                 |                                                  |                                                        |                           |

* Proposed add_rowby variants
In the proposals below, col/cols lalways indicates data column, by is used for splitting criterion where present
** add_rowby(layout, col, by, FUN = summary, drop = FALSE)
Add a subtable corresponding to factor variable <col>, which is split on the variable <by>

drop argument controls whether empty factor legvels are retained (FALSE) or excluded (TRUE)

** add_rowby_all(layout,col, FUN=summary)
Add subtable where row(s) where all data in a variable is summarized (after necessary splits   based on column layout)

** add_rowby_all_multi(layout, cols, FUN = summary)
convenience function, add multiple "rowby_all" type subtables with single function call

Do we want this to default to all columns the df ultimately passed to rtabulate? Not sure.

** add_rowby(layout, col, by, FUN = summary)

** add_rowby_hierarchy(layout, col, by = <vector>, FUN, GROUP_FUN = NULL)
Probably want to change name of GROUP_FUN - if non-null it is the fun used to generate the content tables at  non-leaf  nodes. It should receive the 

l_tte = function(x, col_by, row_by, conf, ...) {
    add_rowby_all(col = "AGE, cinteveral(conf)) %>% ... 


}
