% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colby_constructors.R
\name{split_cols_by_cuts}
\alias{split_cols_by_cuts}
\alias{split_rows_by_dyncut}
\alias{split_cols_by_cutfun}
\alias{split_cols_by_quartiles}
\alias{split_rows_by_quartiles}
\alias{split_rows_by_cutfun}
\title{Split on static or dynamic cuts of the data}
\usage{
split_cols_by_cuts(
  lyt,
  var,
  lbl,
  cuts,
  cutlbls = NULL,
  nested = FALSE,
  cumulative = FALSE
)

split_rows_by_dyncut(
  lyt,
  var,
  lbl,
  cuts,
  cutlbls = NULL,
  format = NULL,
  nested = FALSE,
  lblkids = NA,
  cumulative = FALSE,
  indent_mod = 0L
)

split_cols_by_cutfun(
  lyt,
  var,
  lbl = var,
  cutfun = qtile_cuts,
  cutlblfun = function(x) NULL,
  format = NULL,
  nested = FALSE,
  extra_args = list(),
  cumulative = FALSE,
  indent_mod = 0L
)

split_cols_by_quartiles(
  lyt,
  var,
  lbl = var,
  format = NULL,
  nested = FALSE,
  extra_args = list(),
  cumulative = FALSE
)

split_rows_by_quartiles(
  lyt,
  var,
  lbl = var,
  format = NULL,
  nested = FALSE,
  extra_args = list(),
  cumulative = FALSE,
  indent_mod = 0L
)

split_rows_by_cutfun(
  lyt,
  var,
  lbl = var,
  cutfun = qtile_cuts,
  format = NULL,
  nested = FALSE,
  lblkids = NA,
  cumulative = FALSE,
  indent_mod = 0L
)
}
\arguments{
\item{lyt}{layout object pre-data used for tabulation}

\item{var}{string, variable name}

\item{lbl}{string, label, often variable label}

\item{cuts}{numeric. Cuts to use}

\item{cutlbls}{character (or NULL). Labels for the cutst}

\item{nested}{boolean, Add this as a new top-level split  (defining a new subtable directly under root). Defaults to \code{FALSE}}

\item{cumulative}{logical. Should the cuts be treated as cumulative. Defaults to \code{FALSE}}

\item{format}{format string for cells}

\item{lblkids}{logical. Should the children of this split have label rows. Defaults to \code{NA} which creates a label row only if the child has 0 content rows.}

\item{indent_mod}{numeric. Modifier for the default indent position for the structure created by this function(subtable, content table, or row) \emph{and all of that structure's children}. Defaults to 0, which corresponds to the unmodified default behavior.}

\item{cutfun}{function. Function which accepts the full vector of \code{var} values and returns cut points to be passed to \code{cut}.}

\item{cutlblfun}{function. Function which returns either labels for the cuts or NULL when passed the return value of \code{cutfun}}

\item{extra_args}{list. Extra arguments to be passed to the tabulation function. Element position in thte list corresponds to the children of this split. Named elements in the child-specific lists are ignored if they do not match a formal argument of the ttabulation function.}
}
\description{
Create columns (or row splits) based on values (such as quartiles) of \code{var}.
}
\details{
For dynamic cuts, the cut is transformed into a static cut by
\code{\link{build_table}} \emph{based on the full dataset}, before proceeding. Thus even when nested within another split in column/row space, the resulting split will reflect the overall vaalues (e.g., quartiles) in the dataset, NOT the values for subset  it is nested under.
}
\examples{
l <- basic_table() \%>\%
split_cols_by_cuts("AGE", lbl = "Age", cuts = c(0,25, 35, 1000), cutlbls = c("young", "medium", "old")) \%>\%
analyze("RACE", lbl ="", defrowlab="count", afun = length)

build_table(l, DM)
}
\author{
Gabriel Becker
}
